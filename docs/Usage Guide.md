# Usage Guide

## On this page

* [Generating RTK Definitions]()
  * [Query & Mutation Hooks]()
  * [Default Selectors]()
    * [Collections]()
  * [Cache Structure]()
* [Usage]()
  * [Connect your React app ]()
  * [Injecting data into components]()
  * [Performing mutations]()
  * [State Management]()
* [Caveats]()


For usage with an example, see [here]().

# Generating RTK Definitions 

## Installation & Generation

```bash
npm install @celestial-labs/celestial --save-dev
npx celestial openAPISpec.json outputPath
```

`outputPath` need to be the root of your project. Typically, this contains the index.js that loads your root component.

> Generation of auth is not supported

**Tip:** You can use ChatGPT to generate your OpenAPI specification.

## Query & Mutation Hooks

For each `GET` endpoint, a `usePlaceholderQuery()` hook is generated. Here, `Placeholder` is the camel-case of the **concatenation of the HTTP verb GET and the endpoint**.

For ex., for `/tasks`, the hook will be `useGetTasksQuery()` and for `/issues/issue_id`, the hook will be `useGetIssuesByIssueIdQuery()`. See example [here]().

For each of the `PUT`, `POST` and `DELETE` endpoints, a `usePlaceholderMutation()` hook is generated. See examples [here]().

## Default Selectors

Data fetched from the API calls is provided to the application using **Selectors**. Selectors is RTK's functionality to perform computations. You can think about them as functions. Read more about Selectors [here](https://redux.js.org/usage/deriving-data-selectors#calculating-derived-data-with-selectors).

Celestial groups endpoints into **collections** based on the server resource each endpoint accesses. For ex. `/tasks` and `task/color` endpoints are grouped into the `tasks` collection; and `/colors` and `/colors/color_id` (if this endpoint existed) are grouped into the `colors` collection. 

Celestial generated three default selectors for each **collection** of endpoints:

1. `selectCollection` which returns an array of all items fetched for this collection. More details about this below.
2. `selectCollectionById` which returns an item by id.
3. `selectCollectionIds` which returns an array of ids of all items fetched.

These selectors can be combined to create new selectors. The selector rules defined by [RTK](https://redux-toolkit.js.org/api/createSelector) and [Reselect](https://reselect.js.org/introduction/getting-started#basic-usage) carry over.

### Collections

  Each hook generated by Celestial are belongs to a particular **collection**. The collection a hook belongs to is the hook's `queryHookCollection`.



This allows fine-tuned caching implementation that RTK's default caching strategy. 

By default, collection is the base part of the URL. 

A collection may have multiple query hooks. The hook which is cached corresponds the endpoint that returns a collection of resources (Collection Endpoint in REST) and not a specific resource (Instance Endpoint in REST). For ex. between `/tasks` and `/tasks/task_id`, `/tasks` will be cached and results for `/tasks/task_id` will be served from the cache. 

This behaviour can be customized.

## Cache Structure

When you call a query hook, the corresponding API call is made and the response is cached in the RTK store, under the hook's (endpoint's) collection key.

```json
// Redux store
{
  ...,
  "queryHookCollection" : {
    "entities": {
      id1: {...},
      id2: {...}
  },
    "ids": []
  },
  ...
}
```

The cached data can be accessed using selectors:

```js
useSelector(state);
useSelector((state) => state.queryHookCollection);
```

Besides the cached query data, the state for UI is also stored in the RTK store under the `cache` key.

# Usage

For folks who are familiar with RTK, nothing changes. For folks new to the RTK way of doing things, here is a quick guide.

## Connect your React app 

```js
import { store } from 'celestial/store'
import { Provider } from 'react-redux'

ReactDOM.render(
  <Provider store={store}> // provide the RTK store to the app
    <App />
  </Provider>,
  document.getElementById('root')
)
```


## Injecting data into components

Simply call the hook and then the selector like so.

```js
// import hook
import { usePlaceholderQuery } from "..."

// call the hook at the top of the component
usePlaceholderQuery()

// anywhere in the component
const allData = useSelector(selectCollection)
const allIds = useSelector(selectCollectionIds) 
const item = useSelector(selectCollectionById("id"))
const data = useSelector(selectCustomSelector)
```

If you have called the hook in a previously loaded component, you can simply call the selectors without the hook.

An example can be found [here]().


## Performing mutations

Simply call the hook with arguments required by the corresponding API endpoint.

```js
// import hook
import { usePlaceholderMutation } from "..."

// call the hook at the top of the component
const [updateCall] = usePlaceholderMutation()

// anywhere in the component
// call the mutation with arguments required for the API call
updateCall(...)
```

An example can be found [here]().


## State Management

**Step 1**: Initialize your state variables like so

```js
import { useCacheInit } from "./celestial/cache"

useCacheInit("stateVar1",[]);
useCacheInit("stateVar2","stateVarVal");
```

An example can be found [here]().

**Step 2**: Access your state variables like so

```js
import { selectCache } from "../../celestial/cache";

// anywhere in your component
const { stateVars } = useSelector(selectCache)
```

An example can be found [here]().

**Step 3**: Update your state variables like so

```js
import { useCacheUpdate } from "../../celestial/cache";

// at the top of your component to abide by rules of React Hooks
const cacheUpdate = useCacheUpdate()

// anywhere in your component
cacheUpdate("stateVar1", ['a'])
cacheUpdate("stateVar2", "newValue")
```

An example can be found [here]().

# Caveats

1. Heavily reliant on ids. Assumes that all data returned contains a primary key column named `id`
2. Optimistic updates work if each endpoint modifies an item of an id. For ex., `/tasks/task_id` endpoint modifies a task with id `task_id`. If the endpoint modifies a collection, then the cache is not updated.
3. Does not support auth 
4. Supports only very simple backend (for now)
5. GETs fetch all the data. No support for pagination.